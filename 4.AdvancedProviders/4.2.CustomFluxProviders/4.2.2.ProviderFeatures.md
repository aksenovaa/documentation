4.2.3 Возможности поставщика/Provider
=====================================

![FluidTYPO3 File contexts, Providers](../Images/FileContext/Providers.svgz)

Все возможности класса Provider крутятся вокруг его методов, которые можно при необходимости переназначить. Эти методы можно
разделить на четыре специфичные группы со схожими обязанностями:


| Интеграция            | Шаблоны                         | Записи                       | Компоненты         |
| --------------------- | ------------------------------- | ---------------------------- | ------------------ |
| trigger()             | getTemplatePathAndFilename()    | preProcessRecord()           | getForm()          |
| getExtensionKey()     | setTemplatePathAndFilename()    | postProcessRecord()          | setForm()          |
| getTableName()        | getTemplateVariables()          | postProcessDataStructure()   | getGrid()          |
| setTableName()        | getTemplateVariables()          | preProcessCommand()          | setGrid()          |
| getFieldName()        | getConfigurationSectionName()   | postProcessCommand()         | getPreview()       |
| setFieldName()        | setConfigurationSectionName()   | clearCacheCommand()          |                    |
| getPriority()         |                                 | getFlexFormValues()          |                    |
|                       |                                 | getInheritanceTree()         |                    |

Общим для многих из этих методов является то, что _они в качестве аргумента принимают запись_. Это позволяет перед манипуляциями
сначала проанализировать запись или вернуть значение на основе этого. Например,, `fluidcontent` использует это поведение для
возвращения разных путей к шаблону для разных значений в поле _Fluid content type_. Другой способ использования — в зависимости
 от типа записи из настроек TCA, перед возвращением экземпляра компонента `Form`, вернуть разные формы для каждого типа записи.

## Области ответственности

Методы из столбца **Интеграция** используются TYPO3 при определении поставщиков/Providers и опроса поставщика, способен ли он
обработать текущую запись (во внешнем или внутреннем интерфейсах). getters и setters в этой категории извлекают и настраивают
соответствующие условия — какую таблицу, поле и приоритет имеет ваш поставщик/Provider, а метод `trigger()`, реализованный в
базовом классе как простой метод, получающий название таблицы и поля, и анализирует запись, переданную в качестве аргумента на
предмет её соответствия.

Группа методов **Шаблоны** занимается получением названий файлов шаблонов, наборов предустановленных переменных, возвращенем
названий раздела `Configuration`. Если, например, файл шаблона содержит несколько разделов Configuration, то метод
`getConfigurationSectionName` получает в качестве аргумента запись, на основании свойств которой можно решить, какой из
разделов задействовать.

Группа **Записи** занимается исключительно обработкой записей (и команд, совершаемых над записями, вроде копирования или
удаления). Эти методы могут быть переназначены, чтобы поставщик/Provider мог бы совершать действия, например, перед или после
сохрания записи. Обратите внимание, что `postProcessDataStructure` является низкоуровневой частью поставщика/Provider, и вам
обычно не нужно переназначать именно этот метод, так как единственное, что он делает — преобразовывает экземпляр `Form` в массив
`TCEforms`. Единственный вариант использования при переопределении этого — ручное возвращение массива `TCEforms` и/или ручное изменение существующей структуры данных (включая сформированные другими поставщиками/Providers). Почти всегда, правильным решением при переопределении `Form` —
переопределение метода `getForm`.

Последняя группа **Компоненты** имеет дело с возвращением экземпляров классов `Form` и `Grid`, а также предпросмотром
содержимого (что на данный момент применимо лишь к записям из таблицы элементов содержимого TYPO3, `tt_content`). В
реализациях, хранящих эти типы настроек в файлах шаблонов, эти методы пытаются прочитать данные из шаблонов, но
пользовательские поставщики/Provider могут непосредственно возвращать эти экземпляры. Если, например, ваш поставщик/Provider
возвращает и экземпляр `Form`, и экземпляр `Grid`, в файлах шаблонов больше не обязательно располагать тег `flux:form` или
`f:section` с названием `Configuration`. Действительно, вашему поставщику/Provider больше не нужно возвращать название файла
шаблона, если он напрямую возвращает его экземпляры (если ваш поставщик/Provider используется в контроллере на базе Flux, не
возвращение названия файла шаблона просто заставит контроллер попытаться вывести файл шаблона, связанный с текущим действием).

## Загрузка/опеделение поставщиков/Providers

Поставщики/Providers всегда используются двумя возможными способами:

1. Обнаружение с помощью записи, названия таблицы, названия поля и приоритета.
2. Создания экземпляров вручную (и, при необходимости, настройки их таблиц и названий полей).

Поставщики/Providers, находящиеся, например, во `flux` и `fluidcontent` регистрируются через класс ядря Flux, то есть они могут
 быть определены автоматически, когда Flux определяет сохранение, перемещение и т. п. записи. Эти поставщики/Providers
 регистрируются с обычным приоритетом, а значит, любой поставщик/Provider зарегистрированный с высшим приоритетом будет
 использоваться вместо существующего.

Использование `NULL` в качестве значения для любого соответствующего свойства (`tableName`, `fieldName`, `contentObjectType` и
так далее) определяет вашего поставщика/Provider как обычного, _но с более низким приоритетом_ соответствующего записям из связанной таблицы БД. То есть, если другой класс поставщика/Provider имеет более определённые установки (например, если использует соответствующее `fieldName` со значением,
отличным от NULL), то он вызывается сначала, а ваш поставщик/Provider — после.

Некоторые области Flux способны запрашивать нескольких поставщиков/Providers для компонентов, то есть, например, при получении
структуры `TCEforms`, она может быть обработана несколькими поставщиками/Providers, так что поосторожнее при регистрации
нескольких поставщиков/Providers для одного поля. В некоторых случаях лучше сначала вручную отменить регистрацию старого
названия класса поставщика/Provider перед регистрацией собственного. Отмена регистрации поставщика/Provider производится по
названию класса, что удаляет и предотвращает использование класса с этим названием.

Контроллер на базе Flux также можно выбрать для создания поставщика/Provider для вывода исключительно во внешнем интерфейсе.
Это значит, что можно использовать все возможности для шаблонов (включая возможность преобразования данных, настраиваемых
посредством экземпляра `Form`), но ничего из функционала для внутреннего интерфейса. Обычно просто регистрируют своего
поставщика/Provider для использовния с `list_type` своего дополнениия.

> Небольшое замечание о поставщиках/Providers, прикреплённых к таблице `tt_content`: так как с этой таблицей используется
> множество поставщиков, лучше **проверить нужное зачение `list_type` или `CType` в записи, перед началом манипуляций с записью в
>  классе поставщика/Provider**. Таким образом можно оградить себя от непреднамеренного вызова кода своего поставщика/Provider.
