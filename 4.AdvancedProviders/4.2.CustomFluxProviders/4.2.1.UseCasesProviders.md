4.2.1 Случаи использования пользовательских поставщиков/Providers
=================================================================

![FluidTYPO3 File contexts, Providers](../Images/FileContext/Providers.svgz)

Поставщик/Provider — это класс, который:

1. Всегда связан с одной таблицей базы данных, например, `tt_content` или `pages`, либо со своей таблицей.
2. Обрабатывается через Flux при редактировании, перемещении, сохранении, удалении и т. п. записи из этой таблицы.
3. Имеет переключатели (при обработке записей из связанной  таблицы) для определённых обстоятельств, вроде того, что запись
   `tt_content` имеет `list_type`, соответствующий определённому дополнению.
4. Содержит ряд методов получения информации на основе записи из строки в связанной с поставщиком таблицы.
5. Содержит ряд методов для управления записями из связанной таблицы БД.
6. Используется вашим [контроллером, созданным на базе Flux], при обработке внешними дополнениями для получения важной,
относящейся к выводу информации, вроде используемого контроллера, файла шаблона, путей для объекта View и т. д.

## Иллюстрация целей

Например, поставщик/Provider `fluidcontent`, а именно `ContentProvider`, связан с таблицей `tt_content` и вызывается только
если значение `CType` записи соответствует `fluidcontent_content` (то есть название дополнения для `fluidcontent`).
Этот поставщик/Provider во внутреннем интерфейсе становится ответственным за обработку экземпляров `FluidTYPO3\Flux\Form`, в
зависимости от определённого выбранного элемента `fluidcontent`. Он читает значения, сохранённые в записи путём заполнения и
сохранения форм Flux. Он реагирует на очистку кеша (обновляя хранимые определения доступных шаблонов `fluidcontent`), и
наконец, он интегрируется в `ContentController` из `fluidcontent`, который формирует каждый элемент, — здесь, в контроллере, он
 используется для возвращения переменных, путей к шаблону, необходимого названия контроллера и названия расширения контроллера,
  и тому подобных вещей.

Затем Flux использует эти переменные и настройки для перенаправления запросов к соответствующему контроллеру по названию
расширения (`fluidcontent` использует это для возможности добавления собственного `ContentControllers` в другие расширения).
Так как элемент `fluidcontent` однозначно идентифицируется комбинацией ключа расширения и названием шаблона, этот
поставщик/Provider затем может (получив ключ расширения по этому значению, например `fluidcontent_bootstrap:Alert.html`) определить название класса контроллера, которому Flux должен доверить обработку).

Другие поставщики/Providers могут выбрать совершенно другие способы включения, например, динамического названия файла шаблона,
меняющегося по значению типа записи, либо другие способы различения типов записей таблицы, но этот пример показывает суть
предназначения поставщиков/Providers (без излишней сложности, так как они, разумеется, могут делать гораздо большее).

## Связь внешнего и внутреннего интерфейсов

Класс поставщкика/Provider выступает как связующее звено между внешним и внутренним интерфейсами, но вы можете использовать его
исключительно во внутреннем, либо во внешнем интерфейсах. Основная выгода будет при использовании в паре с [контроллером на
базе Flux] в расширении Extbase, при этом поставщик/Provider выступает как связь между вашими записями и файлом шаблона,
путями, переменными и другими вещами, которые нужны контроллеру для обработки и вывода каждой записи.

Всё это делает поставщика/Provider тем местом, где динамически декларируются шаблоны, пути, обрабатываемые переменные. Так как
поставщик/Provider используется и во внешнем, и во внутреннем интерфейсах, возвращаемые им значения будут теми же в обоих местах.

## Удобно для тестирования

Наряду с отличной концепцией разделения, поставщик/Provider также отлично подходит для модульного тестирования. И, так как он
одинаковым образом работает во внешнем и внутреннем интерфейсах, его правильная работа в одном контексте гарантирует
правильность работы в другом. Так как здесь в основном происходит делегирование сервисам и другим классам, становится просто
подбирать так называемые "разветвители" в тестах. В качестве подарка, Flux предоставляет базовый класс модульного тестирования,
 который при использовании должен сразу же разрешить множество добавляемых методов. Этот класс называется
 `FluidTYPO3\Flux\Tests\Unit\Provider\AbstractProviderTestCase`, его можно запросто использовать для создания подклассов для
 собственного модульного тестирования.

[Контроллер на базе Flux]: ../4.1.CustomFluxControllers/4.1.1.UseCasesControllers.md
