4.2.2 Создание поставщиков/Providers
====================================

![FluidTYPO3 File contexts, Providers](../Images/FileContext/Providers.svgz)

Для определения названия таблицы БД и названия поля (если нужно), с которым связан ваш поставщик/Provider, используйте свойства
 класса их `AbstractProvider`, а именно `tableName`, `fieldName` и так далее. Например, `ContentProvider` из Flux связан с
 таблицей `tt_content`, если заполнено поле `pi_flexform` и когда `CType` (в классе поставщика/Provider называется
 `contentObjectType`) соответствует `fluidcontent_content`.

И наконец, имеется настройка `priority`, которая может понизить или повысить приоритет вашего поставщика/Provider для записей
из связанной таблицы. По умолчанию она равна `50`, и может быть меньше, чтобы сделать поставщика менее важным, и больше - чтобы
 повысить его важность.

> Помните: несколько классов поставщиков/Provider могут быть связаны с той же таблицей и полем. При этом обязанностью класса
> поставщика/Provider становиться проверка, что он не совершает непредсказуемых операций, например, сначала проверить полученную
> запись — является ли она той, которую класс должен обрабатывать.

В некоторых случаях, как при выводе предпросмотра в модуле Страница для `tt_content`, первый поставщих/Provider формирующий
предпросмотр способен остановить других поставщиков/Providers от той же работы; то есть, в частности, когда поставщик/Provider
связан с таблицей `tt_content`, необходимо быть немного осторожней, и не переназначать приоритет, например `fluidcontent` для
ContentProvider, иначе можно запретить вывод вложенных ячеек для содежимого.

## Чего не должно быть в поставщике/Provider?

Для _отделения частей_ приоложений, основная ответственность вашего поставщика/Provider должна быть _делегированием_ к другим
методам. Например, поставщик/Provider может...

* Внедрять сервисы из ваших приложений, управляющих записями.
* Использовать ConfigurationManager для помещения TypoScript в переменные шаблона из разных мест.
* Динамично удалять и изменять переменные шаблона, перед тем, как они достигнут контроллера/Controller.
* Динамично изменять пути к шаблону, которые должен использовать [контроллер на базе Flux](../4.1.CustomFluxControllers/4.1.1.UseCasesControllers.md).
* Переключать файл шаблона, выводимый вашим контроллером, на базе значений в записях, которые он обрабатывает.
* Возвращать пользовательский экземпляр `FluidTYPO3\Flux\Form`, созданный непосредственно на PHP.
* Настравиать некоторые (не все!) аспекты контекста контроллера — ключ расширения, хранение `$this->settings` и тому подобное.

Но он не должен...

* Содержать большие куски бизнес-логики, например, сложное управление записями.
* Использовать специализированные методы, работающие исключительно во внутреннем или внешнем интерфейсах.

## Использование возможностей поставщика/Provider

Чтобы методы поставщика/Provider вызывались в соответствующих местах, просто зарегистрируйте поставщика/Provider, а Flux
позаботится об остальном. Переназначайте нужное вам количество методов, чтобы поставщик/Provider должным образом выполнял свою
работу. Перед переназначением метода, сначала проверьте оригинальный — скорее всего метод класса в поставщике вызывает другие,
зачастую в том же классе (например, `getTemplateVariables` вызывается из многих мест, но `getGrid` вызывается только извне).
Основными приоритетами должны быть поиск нужного для переопределения метода и проверка того, что изменения безопасны. Отличный
пример переназначения методов в своём поставщике/Providers — ContentProvider из `flux` и PageProvider из `fluidpages`. Каждый из них переназначает свой раздел методов в базовом классе Provider для получения двух совершенно разных результатов.
