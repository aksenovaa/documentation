1.6 Fluid - лучшие решения
==========================

## Правила именования

Во Fluid всегда необходимо следовать правилу `UpperCamelCase` для именования файлов, например, `MyTemplateFile.html`. То же справедливо и для Шаблонных частей/Partials и Макетов/Layouts. Сам Fluid поддерживает множество форматов, но Fluid Powered TYPO3 на данный момент поддерживает лишь один формат: `.html`.

Шаблонные части/Partials и Макеты/Layouts могут размещаться в подпапках, и указыватся с упоминаниме в пути подпапок:

```xml
<!-- Using EXT:myextensionkey/Resources/Private/Layouts/Subfolder/MyLayout.html -->
<f:layout name="Subfolder/MyLayout" />

<!-- Rendering EXT:myextensionkey/Resources/Private/Partials/Subfolder/MyPartial.html -->
<f:render partial="Subfolder/MyPartial" />
```

Формат `UpperCamelCase` должен использоваться для:

* Всех названий классов PHP в расширении поставщике;
* Всех шаблонов - Layouts, Partials и Templates;
* Всех `f:section`, использующихся во всех шаблонах.
 
Формат `lowerCamelCase` (без подчёркиваний) должен использоваться для:

* Каждого названия аргумента в каждом проекторе/ViewHelper;
* Каждой назначаемой в шаблонах переменной;
* Каждого названия поля, создаваемого при помощи Flux (`dotted.path.actualName` также подходит);
* Каждой функции, создаваемой в каждом классе PHP и для каждого аргумента в этих функциях;
* Каждой переменной, используемой в PHP;
* Каждого названия языковой метки (`dotted.path.actualName` также подходит).
 
Формат `lowercase_underscored` (без символов в верхнем регистре) используется только для:

* Ссылок на **ключ** расширения (который отличается от **названия** расширения во Fluid и Extbase), _за исключением ссылок в TypoScript местоположения для своего расширения_;
* **Старых** языковых меток (текущий формат, как было сказано выше, `lowerCamelCase`).

> Помните о подчёркиваниях в ключах расширений: расширение с названием `my_extension` указывается как `MyExtension`, если указан формат `extensionName`, и как `my_extension`, когда указан формат `extensionKey`, и наконец, как `Vendor.MyExtension`, если формат (например) `combinedExtensionKey` (но зачастую возможно использовать и когда указан формат `extensionName` **и нет отдельного аргумента `vendorName`). Из-за столь экзотичного поведения, главная рекомендация: **избегайте подчёркиваний в ключах расширений**. Если, конечно, вы знаете, что делаете.

## По поводу производительности Fluid

Fluid работает, анализируя и приводя шаблоны к структуре объектов PHP. Каждый проектор/ViewHelper, используемый внутри другого проектора/ViewHelper увеличивает уровень вложенности (например, `f:link.page` внутри `f:if` выводит `f:link.page` изнутри класса, обрабатывающего тег `f:if`). Чем меньше уровень вложенности, тем меньше функций вызывается, а уменьшение количество используемых тегов проекторов/ViewHelper актуально снижает время на формирование шаблонов Fluid.

Нужно взять за правило, разбивать содержимое файлов шаблонов на шаблонные фрагменты/Partial. Так как шаблонные фрагменты/Partial ещё и кешируются, как PHP, это может быть очень полезно для разгрузки при выводе. Особенно, если вывод осуществляется сразу в нескольких частях.

> Замечание: даже формы и поля Flux можно разместить в шаблонных фрагментах/Partial, и даже разбить на `f:section` внутри этих шаблонных фрагментов/Partial. Просто `f:render` шаблонный фрагмент/Partial (и раздел/section) изнутри тега `flux:form`, и Fluid вызовет нужный код PHP для создания необходимых полей форм, и вставит в нужный контейнерный элемент (Sheet, Object и такого типа).

В целях повышения скорости вывода, Fluid закеширует некоторые проекторы/ViewHelpers, как чистый код PHP, но, если Fluid встретит так называемый `некомпилируемый` проектор/ViewHelper в шаблоне, _шаблон не сможет преобразоваться в чистый код PHP_. Чтобы определить это, можно воспользоваться расширением `builder`, либо можно изучить классы используемых проекторов/ViewHelper, проверив на вхождение интерфейса `ChildNodeAccessor` в классы, не имеющих метода `compile()`. К сожалению, Fluid не имеет флага отладки, который можно было бы установить для предупреждения о подобных проекторах/ViewHelpers, поэтому рекомендуется запускать `builder` для проверки (в частности перед запуском шаблона). Избегание некомпилируемых проекторов/ViewHelpers (или, если это невозможно, размещение их в отдельных шаблонных фрагментах/Partial с небольшим количеством кода) — ключ к хорошей производительности при использовании шаблонов Fluid.

После кеширования _внутри кеша страницы/содержимого_, Fluid не влияет на скорость вывода страниц. Влияет он лишь при _создании страницы_, и, если шаблоны Fluid поддаются компиляции, при следующей загрузке вывод страницы значительно ускорится.

Разумеется, фокус должен быть в первую очередь на производительности шаблонов страниц, а во вторую — на шаблонах содержимого. Шаблоны страниц, компилированные в простой PHP _значительно более эффективны_, так как после первичного формирования страницы, все последующие страницы будут формироваться на основе кода PHP, _полностью пропуская шаг анализа шаблона_.

## Переменные и производительность

Шаблоны Fluid широко используют переменные, значение которых можно установить извне шаблона. Так как сами по себе переменные не сильно увеличивают использование CPU и памяти, но они усложняют шаблоны и увеличивают вероятность коллизий, которые необходимо разрешить при формировании шаблона. Можно ограничить количество переменные и снизить риск коллизий, следуя следующим простым правилам:

* Ограничте использование `v:variable.set`, но используйте их чаще, если поймаете себя на использовании длинных цепочек тегов Fluid при манипулировании определёнными переменными. Избегание длинных дублирующихся цепочек Fluid ограничивает количество методов, которые должен вызвать Fluid.
* Be conservative about passing the special `{_all}` keyword variable when rendering sections and Partials. When you do, every variable is passed which makes it both harder to know which variables are available in the Partial or section - but also makes Fluid create a copy of the entire arguments array. This is always a trade-off: having to pass too many variables means Fluid needs to parse many additional template nodes so sometimes, `{_all}` can be more efficient - but less transparent

## Don't Fear Custom ViewHelpers

Sometimes the ViewHelpers provided in Fluid and VHS are not enough to get you where you need to be - and sometimes you need to use so many different ViewHelpers that performance suffers as a consequence. If you encounter such a case it's always a good idea to ask if your use case makes sense as an addition to VHS - but if it is not, you have a great option right at hand: making and using a custom ViewHelper class.

Since Fluid Powered TYPO3 requires you to use an extension for your template files you already have the perfect place to create custom ViewHelpers. You can use virtually any ViewHelper in VHS or Fluid (note: there are four main types, in order of most frequent occurrence they are standard, tag-based, condition and finally widget types) as a starting point. Include your own namespace same as you include the VHS namespace - and you've got a perfect way to do more complex PHP operations without having to create a custom controller class.

Continue: [Chapter 1.7: Portable code](1.7.PortableCode.md).
